#!/usr/bin/env bash

#
# ~/.bash_prompt
#

if [[ $COLORTERM = gnome-* && $TERM = xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
    export TERM='gnome-256color';
elif infocmp xterm-256color >/dev/null 2>&1; then
    export TERM='xterm-256color';
fi;

# FOREGROUND COLOR SCHEME
if tput setaf 1 &> /dev/null; then
    tput sgr0;
    bold=$(tput bold);
    reset=$(tput sgr0);
    fgBlack=$(tput setaf 16);
    fgRed=$(tput setaf 203);
    fgGreen=$(tput setaf 71);
    fgYellow=$(tput setaf 226);
    fgBlue=$(tput setaf 33);
    fgMagenta=$(tput setaf 161);
    fgCyan=$(tput setaf 38);
    fgWhite=$(tput setaf 231);
    fgPink=$(tput setaf 161);
    fgPurple=$(tput setaf 127);
    fgDeeppurple=$(tput setaf 55);
    fgIndigo=$(tput setaf 25);
    fgLightblue=$(tput setaf 39);
    fgTeal=$(tput setaf 30);
    fgLightgreen=$(tput setaf 112);
    fgLime=$(tput setaf 184);
    fgAmber=$(tput setaf 214);
    fgOrange=$(tput setaf 208);
    fgDeeporange=$(tput setaf 202);
    fgBrown=$(tput setaf 94);
    fgGray=$(tput setaf 102);
else
    bold='';
    reset="\e[0m";
    fgDefault="\e[39m;"
    fgBlack="\e[30m;"
    fgRed="\e[31m;"
    fgGreen="\e[32m;"
    fgYellow="\e[33m;"
    fgBlue="\e[34m;"
    fgMagenta="\e[35m;"
    fgCyan="\e[36m;"
    fgDarkgray="\e[90m;"
    fgLightgray="\e[37m;"
    fgLightred="\e[91m;"
    fgLightgreen="\e[92m;"
    fgLightyellow="\e[93m;"
    fgLightblue="\e[94m;"
    fgLightmagenta="\e[95m;"
    fgLightcyan="\e[96m;"
    fgWhite="\e[97m;"
fi;

# BACKGROUND COLOR SCHEME
if tput setab 1 &> /dev/null; then
    tput sgr0;
    bgBlack=$(tput setab 16);
    bgRed=$(tput setab 203);
    bgGreen=$(tput setab 71);
    bgYellow=$(tput setab 226);
    bgBlue=$(tput setab 33);
    bgMagenta=$(tput setab 161);
    bgCyan=$(tput setab 38);
    bgWhite=$(tput setab 231);
    bgPink=$(tput setab 161);
    bgPurple=$(tput setab 127);
    bgDeeppurple=$(tput setab 55);
    bgIndigo=$(tput setab 25);
    bgLightblue=$(tput setab 39);
    bgTeal=$(tput setab 30);
    bgLightgreen=$(tput setab 112);
    bgLime=$(tput setab 184);
    bgAmber=$(tput setab 214);
    bgOrange=$(tput setab 208);
    bgDeeporange=$(tput setab 202);
    bgBrown=$(tput setab 94);
    bgGray=$(tput setab 102);
else
    bgDefault="\e[49m";
    bgBlack="\e[40m";
    bgRed="\e[41m";
    bgGreen="\e[42m";
    bgYellow="\e[43m";
    bgBlue="\e[44m";
    bgMagenta="\e[45m";
    bgCyan="\e[46m";
    bgDarkgray="\e[100m";
    bgLightgray="\e[47m";
    bgLightred="\e[101m";
    bgLightgreen="\e[102m";
    bgLightyellow="\e[103m";
    bgLightblue="\e[104m";
    bgLightmagenta="\e[105m";
    bgLightcyan="\e[106m";
    bgWhite="\e[107m";
fi;

prompt_git() {
    local s='';
    local branchName='';

    # Check if the current directory is in a Git repository.
    if [ $(git rev-parse --is-inside-work-tree &>/dev/null; echo "${?}") == '0' ]; then

        # check if the current directory is in .git before running git checks
        if [ "$(git rev-parse --is-inside-git-dir 2> /dev/null)" == 'false' ]; then

            # Ensure the index is up to date.
            git update-index --really-refresh -q &>/dev/null;

            # Check for uncommitted changes in the index.
            if ! $(git diff --quiet --ignore-submodules --cached); then
                s+="${i_oct_plus} ";
            fi;

            # Check for unstaged changes.
            if ! $(git diff-files --quiet --ignore-submodules --); then
                s+="${i_oct_zap} ";
            fi;

            # Check for untracked files.
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                s+="${i_oct_x} ";
            fi;

            # Check for stashed files.
            if $(git rev-parse --verify refs/stash &>/dev/null); then
                s+="${i_oct_squirrel} ";
            fi;

        fi;

        # Get the short symbolic ref.
        # If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
        # Otherwise, just give up.
        branchName="$(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')";

        [ -n "${s}" ] && s="[ ${s}]";

        gitHubLogo="${i_oct_octoface} ";

        echo -e " ${gitHubLogo}${1}${branchName} ${2}${s}";
    else
        return;
    fi;
}

# Platform Dependent Prompt Symbols
if [[ -z "$PS_SYMBOL" ]]; then
    case "$(uname)" in
        Darwin)   PS_SYMBOL="${i_dev_apple} ";;
        Linux)    PS_SYMBOL="${i_dev_linux} ";;
        *)        PS_SYMBOL="${i_dev_windows} ";;
    esac
fi

# Highlight The User Name When Logged In As Root.
if [[ "${USER}" == "root" ]]; then
    userStyle="${bold}${fgRed}";
else
    userStyle="${bold}${fgOrange}";
fi;

# Highlight The Hostname When Connected Via Ssh.
if [[ "${SSH_TTY}" ]]; then
    hostStyle="${bold}${fgRed}";
else
    hostStyle="${fgYellow}";
fi;

# SET THE TERMINAL TITLE TO THE CURRENT WORKING DIRECTORY.
PS1="\[\033]0;\w\007\]";
# NEWLINE
PS1+="\n";
# USERNAME
#PS1+="\[${userStyle}\]\u";
#PS1+="\[${white}\]@";
# HOST
#PS1+="\[${hostStyle}\]\h";
#PS1+="\[${white}\] in ";
# WORKING DIRECTORY
PS1+="\[${bgLightblue}${fgBlack}\] ${i_mdi_folder_open} ~/\W ";
# GIT REPOSITORY DETAILS
PS1+="\[${bgGreen}\]\$(prompt_git \" ${i_oct_git_branch} \" \"\")\[${reset}\]";
PS1+="\n";
# OS SYMBOL
PS1+="\[${fgGreen}\] ${PS_SYMBOL}\[${reset}\]";
export PS1;

PS2="\[${fgYellow}\]→ \[${reset}\]";
export PS2;
